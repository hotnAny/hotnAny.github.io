// console.log(obj.geometry.vertices[ vlist[0]] + ", " 
		// 	+ obj.geometry.vertices[ vlist[1]] + ", "
		// 	+ obj.geometry.vertices[ vlist[2]]);
		// console.log(vlist);
		// simpleSort(vlist);
		// console.log(vlist);
		// console.log();

// for(var j=0; j<obj.geometry.faces.length; j++) {
		// 	var ff = obj.geometry.faces[j];
			// console.log(ff);
			// break;
			// var vaa = obj.geometry.vertices[ff.a].clone().applyMatrix4(obj.matrixWorld);
			// var vbb = obj.geometry.vertices[ff.b].clone().applyMatrix4(obj.matrixWorld);
			// var vcc = obj.geometry.vertices[ff.c].clone().applyMatrix4(obj.matrixWorld);

			// addATriangle(va2, vb2, vc2, 0xff0000);
			// if(f.a == f2.a || f.a == f2.b || f.a == f2.c ||
			//    f.b == f2.a || f.b == f2.b || f.b == f2.c ||
			//    f.c == f2.a || f.c == f2.b || f.c == f2.c)

// console.log(vlist2);
			// simpleSort(vlist2);

			// var idx0 = findNextEqualPair(0, vlist, vlist2);
			// if(idx0 >= 0 && idx0 < vlist2.length-1) {
			// 	var idx1 = findNextEqualPair(idx0+1, vlist, vlist2);
			// 	if(idx1 >= 0) {
			// 		f.neighbors.push(ff);
			// 		// ff.neighbors.push(f);
			// 	}
			// }

// console.log(vlist2);
			// simpleSort(vlist2);

			// var idx0 = findNextEqualPair(0, vlist, vlist2);
			// if(idx0 >= 0 && idx0 < vlist2.length-1) {
			// 	var idx1 = findNextEqualPair(idx0+1, vlist, vlist2);
			// 	if(idx1 >= 0) {
			// 		f.neighbors.push(ff);
			// 		// ff.neighbors.push(f);
			// 	}
			// }
// function sameVertex(obj, idx0, idx1) {

// }

// function simpleSort(vlist) {
// 	for(var i=0; i<vlist.length; i++) {
// 		for(var j=i+1; j<vlist.length; j++) {
// 			if(vlist[j] < vlist[i]) {
// 				var tmp = vlist[i];
// 				vlist[i] = vlist[j];
// 				vlist[j] = tmp;
// 			}
// 		}
// 	}
// }

// function findNextEqualPair(idx, list1, list2) {
// 	for(var i=idx; i<list1.length; i++) {

// 	}
// }

// function contains(array, elm) {
// 	for(var i=0; i<array.length; i++) {
// 		if(array[i] === elm) {
// 			return true;
// 		}
// 	}
// 	return false;
// }


		// if(f.neighbors.length < 3) {
		// 	console.log(f.neighbors.length);
		// 	addATriangle(va, vb, vc, 0xff0000);
		// 	for(var i=0; i<f.neighbors.length; i++) {
		// 		var ff = f.neighbors[i];
		// 		var vaa = obj.geometry.vertices[ff.a].clone().applyMatrix4(obj.matrixWorld);
		// 		var vbb = obj.geometry.vertices[ff.b].clone().applyMatrix4(obj.matrixWorld);
		// 		var vcc = obj.geometry.vertices[ff.c].clone().applyMatrix4(obj.matrixWorld);

		// 		addATriangle(vaa, vbb, vcc, 0xffff00);
		// 	}
		// 	break;
		// }